/*========================================================================*/
/* NOM DU FICHIER  : vexploitWireless.c	                                  */
/*========================================================================*/
/* Compilateur     : GCC                                                  */
/* Linking locator : GCC                                                  */
/* Formatter       : GCC                                                  */
/* Auteur          : CM                                                   */
/* Date			   : 26/10/2009                                           */
/* Libelle         : HTML CGI: page HTML exploitation Wifi				  */
/* Projet          : WRM100                                               */
/* Indice          : BE058                                                */
/*========================================================================*/
/* Historique      :                                                      */
//BE000 24/09/09 CM
// - CREATION
//BE007 25/01/2010 CM
// - Ajout exploitation de l'ACCESS POINT
//BE014 08/03/2010 CM
// - Ajout option compilation "-Wall" + correction w@rning
//BE051 13/12/2010 CM
// - Ajout exploitation SSID (utile si dual ssid activé)
//BE054 11/01/2011 CM
// - Ajout gestion mode monitor
//BE058 21/01/2011 CM
// - Ajout dans exploitation du canal en cours (sur AP et STA)
/*========================================================================*/


/*_____I - COMMENTAIRES - DEFINITIONS -  REMARQUES _______________________*/

/*_____II - DEFINE SBIT __________________________________________________*/

#define _VEXPLOITWIRELESS


/*_____III - INCLUDE - DIRECTIVES ________________________________________*/
#include "../services.h"

/*_____IV - VARIABLES GLOBALES ___________________________________________*/

/*_____V - PROCEDURES ____________________________________________________*/

//=====================================================================================
// Fonction		: VExploitWireless_Dyn
// Entrees		: <loc_p_varlist< : liste des paramètres URL
//				  <loc_s32_form_method> : méthode du formulaire
// Sortie		: Rien
// Auteur		: CM - 26/10/2009
// Description	: Page rafraichissement page Exploit Wifi
//				"URL=VExploitWireless_Dyn
//=====================================================================================
void VExploitWireless_Dyn(s8sod **loc_p_varlist, s32sod loc_s32_form_method)
{
	s32sod				loc_s32_sem;

//	printf("Content-type: text/html\n\n");/* Mandatory */
	printf("Content-type: text/plain\n\n");/* Mandatory */

	// Entrée au setup par mot de passe
	if(!TestClientIpConnecte(getenv("REMOTE_ADDR")))
	{
		html_tag("|");
		html_tag("&&&id:RECHARGER_PAGE_HTML&&&"); //id inconnu donc recharge de la page
	}
	
	s32Lock_Get(SEMAPHORE_BDD_CONFIG_EQPT, &loc_s32_sem);	//on lève le sémaphore
	if(FALSE == u8FillConfigGeneral(&s_html_cfg_eqpmt))
	{
		html_tag("|");
		html_tag("&&&id:RECHARGER_PAGE_HTML&&&"); //id inconnu donc recharge de la page
	}
	else
	{
		switch(s_html_cfg_eqpmt.s_gene.u8_mode_radio_modem)
		{
			case MODE_RADIO_MODEM_STATION:
				break;
			case MODE_RADIO_MODEM_ACCESS_POINT:
				if(FALSE == u8FillConfigWifi(&s_html_cfg_eqpmt))
				{
					html_tag("|");
					html_tag("&&&id:RECHARGER_PAGE_HTML&&&"); //id inconnu donc recharge de la page
				}
				break;
			case MODE_RADIO_MODEM_MONITOR:
				html_tag("|");
				html_tag("&&&id:RECHARGER_PAGE_HTML&&&"); //id inconnu donc recharge de la page
				break;
			default:
				break;
		}
	}	
	s32Lock_Release(SEMAPHORE_BDD_CONFIG_EQPT, &loc_s32_sem);	//on relache le sem


	s32Lock_Get(SEMAPHORE_BDD_EXPLOIT, &loc_s32_sem);	//on lève le sémaphore
	switch(s_html_cfg_eqpmt.s_gene.u8_mode_radio_modem)
	{
		case MODE_RADIO_MODEM_STATION:
			if(FALSE == u8FillExploitStationFile(&s_html_exploit.s_station))
			{
				html_tag("|");
				html_tag("&&&id:RECHARGER_PAGE_HTML&&&"); //id inconnu donc recharge de la page
			}
			break;
		case MODE_RADIO_MODEM_ACCESS_POINT:
			if(FALSE == u8FillExploitAccessPointFile(&s_html_exploit.s_access_point))
			{
				html_tag("|");
				html_tag("&&&id:RECHARGER_PAGE_HTML&&&"); //id inconnu donc recharge de la page
			}
			break;
		case MODE_RADIO_MODEM_MONITOR:
			break;
		default:
			break;
	}
	s32Lock_Release(SEMAPHORE_BDD_EXPLOIT, &loc_s32_sem);	//on relache le sem

	switch(s_html_cfg_eqpmt.s_gene.u8_mode_radio_modem)
	{
		case MODE_RADIO_MODEM_STATION:
			//Statut de la connexion
			html_tag("|");
			html_tag("&&&id:SPAN_STATUT&&&innerHTML:%s&&&",
					 ps8ConvertChaineToHtml(pt_tb_msg[u8_html_langue].ps8_msg_choix_station_connexion[s_html_exploit.s_station.u8_statut_connexion]));
			//BSSID
			html_tag("|");
			if(STATUT_CONNEXION__ASSOCIATED == s_html_exploit.s_station.u8_statut_connexion)
			{
				html_tag("&&&id:SPAN_BSSID&&&innerHTML:%s&&&",
						 ps8GetChAddressMac(s_html_exploit.s_station.pu8_bssid_add_mac));
			}
			else
			{
				html_tag("&&&id:SPAN_BSSID&&&innerHTML:?&&&");
			}
			//ESSID
			html_tag("|");
			html_tag("&&&id:SPAN_ESSID&&&innerHTML:%s&&&",
					 ps8ConvertChaineToHtml(s_html_exploit.s_station.ps8_ssid_inprogress));

#ifdef _WRM100_N_SELECT
			//Canal utilisé
			html_tag("|");
			if(CHANNEL_RADIO_DISABLED != s_html_exploit.s_station.u16_channel_inprogress)
			{
				html_tag("&&&id:SPAN_CHANNEL&&&innerHTML:%d MHz - CH=%d&&&",
						 s_html_exploit.s_station.u16_freq_MHz_inprogress,
						 s_html_exploit.s_station.u16_channel_inprogress);
			}
			else
			{
				html_tag("&&&id:SPAN_CHANNEL&&&innerHTML:? MHz - CH=?&&&");
			}
#endif
			
			//RSSI
			html_tag("|");
			if(STATUT_CONNEXION__ASSOCIATED == s_html_exploit.s_station.u8_statut_connexion)
			{
				html_tag("&&&id:SPAN_RSSI&&&innerHTML:%ld dBm&&&",
						 s_html_exploit.s_station.s32_rssi_dbm);
			}
			else
			{
				html_tag("&&&id:SPAN_RSSI&&&innerHTML:? dBm&&&");
			}
			break;
		case MODE_RADIO_MODEM_ACCESS_POINT:
			//ESSID
			html_tag("|");
			html_tag("&&&id:SPAN_ESSID&&&innerHTML:%s&&&",
					 ps8ConvertChaineToHtml(s_html_cfg_eqpmt.s_wifi.ps8_ssid_primary));
#ifdef _WRM100_N_SELECT
			//Canal utilisé
			html_tag("|");
			if(CHANNEL_RADIO_DISABLED != s_html_exploit.s_access_point.u16_channel_inprogress)
			{
				html_tag("&&&id:SPAN_CHANNEL&&&innerHTML:%d MHz - CH=%d&&&",
						 s_html_exploit.s_access_point.u16_freq_MHz_inprogress,
						 s_html_exploit.s_access_point.u16_channel_inprogress);
			}
			else
			{
				html_tag("&&&id:SPAN_CHANNEL&&&innerHTML:? MHz - CH=?&&&");
			}
#endif
			//Liste des clients Wifi
			HtmlDyn_TableClientWifi();
			break;
		case MODE_RADIO_MODEM_MONITOR:
			break;
		default:
			break;
	}
	
	html_tag("|");

	
}/*VExploitWireless_Dyn*/

//=====================================================================================
// Fonction		: HtmlDyn_TableClientWifi
// Entrees		: rien
// Sortie		: rien
// Auteur		: CM - 04/11/2009
// Description	: Code HTML de la table des clients Wifi (dynamique)
//=====================================================================================
void HtmlDyn_TableClientWifi(void)
{
	u16sod loc_u16_i;

	for(loc_u16_i=0;loc_u16_i<NB_ASSOCIATED_STATIONS_MAX;loc_u16_i++)
	{
		if(TRUE == s_html_exploit.s_access_point.s_wifi_client[loc_u16_i].u8_present)
		{
			html_tag("|");
			sprintf(ps8_html_string, "%-30s%-20ld%s",
					ps8GetChAddressMac(s_html_exploit.s_access_point.s_wifi_client[loc_u16_i].pu8_add_mac),
					s_html_exploit.s_access_point.s_wifi_client[loc_u16_i].s32_rssi_dbm,
					ps8GetChStatutClientWifi(s_html_cfg_eqpmt.s_wifi.u8_mode_securite_wifi, s_html_exploit.s_access_point.s_wifi_client[loc_u16_i].u32_statut, u8_html_langue));
			
			html_tag("&&&id:SPAN_WIFI%s&&&innerHTML:%s&&&",
					 ps8GetChAddressMac(s_html_exploit.s_access_point.s_wifi_client[loc_u16_i].pu8_add_mac),
					 ps8ConvertChaineToHtml(ps8_html_string));
		}
	}

	//On surveille le nombre de clients wifi connectés
	html_tag("|");
	html_tag("&&&id:SPAN_NB_CLIENTS_WIFI_%d&&&innerHTML:&&&",
			 s_html_exploit.s_access_point.u16_nb_associations);
}/*HtmlDyn_TableClientWifi*/

//=====================================================================================
// Fonction		: VExploitWireless
// Entrees		: <loc_p_varlist< : liste des paramètres URL
//				  <loc_s32_form_method> : méthode du formulaire
// Sortie		: Rien
// Auteur		: CM - 26/10/2009
// Description	: Page HTML Exploitation: Paramètres Wifi
//				"URL=VExploitWireless"
//=====================================================================================
void VExploitWireless(s8sod **loc_p_varlist, s32sod loc_s32_form_method)
{
	s32sod				loc_s32_sem;

	printf("Content-type: text/html\n\n");/* Mandatory */
	
	// Entrée au setup par mot de passe
	if(!TestPassword(getenv("REMOTE_ADDR"), LOW_LEVEL_ACCESS))
	{
		PreparePagePswd("VExploitWireless");
		return;
	}

	//Lecture de la base de données
	s32Lock_Get(SEMAPHORE_BDD_CONFIG_EQPT, &loc_s32_sem);	//on lève le sémaphore
	if(FALSE == u8FillConfigGeneral(&s_html_cfg_eqpmt))
	{
		u8_html_base_donnees_inaccessible = TRUE; //defaut accès bdd
	}
	else
	{
		switch(s_html_cfg_eqpmt.s_gene.u8_mode_radio_modem)
		{
			case MODE_RADIO_MODEM_STATION:
				break;
			case MODE_RADIO_MODEM_ACCESS_POINT:
				if(FALSE == u8FillConfigWifi(&s_html_cfg_eqpmt))
				{
					u8_html_base_donnees_inaccessible = TRUE; //defaut accès bdd
				}
				break;
			case MODE_RADIO_MODEM_MONITOR:
				break;
			default:
				break;
		}
	}
	s32Lock_Release(SEMAPHORE_BDD_CONFIG_EQPT, &loc_s32_sem);	//on relache le sem


	s32Lock_Get(SEMAPHORE_BDD_EXPLOIT, &loc_s32_sem);	//on lève le sémaphore
	if(FALSE == u8FillExploitGeneralFile(&s_html_exploit.s_general))
	{
		u8_html_base_donnees_inaccessible = TRUE; //defaut accès bdd
	}
	switch(s_html_cfg_eqpmt.s_gene.u8_mode_radio_modem)
	{
		case MODE_RADIO_MODEM_STATION:
			if(FALSE == u8FillExploitStationFile(&s_html_exploit.s_station))
			{
				u8_html_base_donnees_inaccessible = TRUE; //defaut accès bdd
			}
			break;
		case MODE_RADIO_MODEM_ACCESS_POINT:
			if(FALSE == u8FillExploitAccessPointFile(&s_html_exploit.s_access_point))
			{
				u8_html_base_donnees_inaccessible = TRUE; //defaut accès bdd
			}
			break;
		case MODE_RADIO_MODEM_MONITOR:
			break;
		default:
			break;
	}
	s32Lock_Release(SEMAPHORE_BDD_EXPLOIT, &loc_s32_sem);	//on relache le sem

	//Test si accès au contenu page 
	if(FALSE == u8TestStartHtml()) //CONDITION: accès au contenu page HTML immpossible
	{
		return; // on sort!
	}
	
	//Page inaccessible en mode MONITOR
	if(MODE_RADIO_MODEM_MONITOR == s_html_cfg_eqpmt.s_gene.u8_mode_radio_modem)  //CONDITION: MONITOR
	{
		sprintf(ps8_pageHtmlRetour,"/cgi-bin/cgi_fh?URL=Vwarning&%d",
				WARNING_INDISPONIBLE_MODE_MONITOR);
		Html_GotoPage(ps8_pageHtmlRetour);
		return;
	}
	

	html_tag("<html> \n");
	html_tag("<head> \n");
	html_tag("<title>%s: %s</title> \n",
			 pt_tb_msg[u8_html_langue].ps8_msg_exploitation,
			 pt_tb_msg[u8_html_langue].ps8_msg_wifi);
	html_tag("<LINK href=\"../style.css\" type=text/css rel=stylesheet></LINK> \n");
	html_tag ("<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\"> \n");
	html_tag ("<meta http-equiv=\"Pragma\" content=\"no-cache\"> \n");
	html_tag ("<meta http-equiv=\"Expires\" content=\"-1\"> \n");
	html_tag("</head> \n");

	html_tag("<body> \n");

	JSActualiser("/cgi-bin/cgi_fh?URL=VExploitWireless");	//pour la fonction Actualiser
	RefreshContentsOfFrame("/cgi-bin/cgi_fh?URL=VExploitWireless_Dyn", (u32sod)u16GetTpsRefreshHtml()*1000);
	

	html_tag("<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"580\"> \n");
	html_tag("<TR><TD vAlign=top height=40><P class=header>%s: %s</P></TD></TR> \n",
			 pt_tb_msg[u8_html_langue].ps8_msg_exploitation,
			 pt_tb_msg[u8_html_langue].ps8_msg_wifi);
	switch(s_html_cfg_eqpmt.s_gene.u8_mode_radio_modem)
	{
		case MODE_RADIO_MODEM_STATION:
			html_tag("<tr><td><P>%s</P></td></tr> \n",
					 pt_tb_msg[u8_html_langue].ps8_msg_sous_titre_VExploitWifi_station);
			break;
		case MODE_RADIO_MODEM_ACCESS_POINT:
			html_tag("<tr><td><P>%s</P></td></tr> \n",
					 pt_tb_msg[u8_html_langue].ps8_msg_sous_titre_VExploitWifi_ap);
			break;
		case MODE_RADIO_MODEM_MONITOR:
			break;
		default:
			break;
	}
	html_tag("<tr><td>&nbsp;</td></tr> \n");

	//	===========================================
	//	AFFICHAGE D'INFORMATIONS
	//	communes à toutes les pages HTML
	//	===========================================
	AfficheDansToutesLesPages();

#if 0
	html_tag("<tr><td><P class=undermenu>&nbsp;</P></td></tr> \n");

	if(TRUE == u8TestGroupeEvtDisponible(GROUPE_AL_ASI))
	{
		html_tag("<tr><td><table  align=center border=\"1\" cellpadding=\"2\" cellspacing=\"1\"> \n");
		html_tag("	<tr height=20> \n");
		html_tag("   <th width=200><a href=\"/cgi-bin/cgi_fh?URL=VAlarme&param=%d\" target=\"frame_c\">%s</a></th> \n",
				 GROUPE_AL_ASI,
				 pt_tb_msg[u8_html_langue].ps8_msg_lib_groupe_alarmes[GROUPE_AL_ASI]);
		HtmlTD_ConvStatAlarme(u8GetEtatGroupeAlarme(GROUPE_AL_ASI),"GROUPE_AL_ASI",100);
		html_tag("	</tr>\n");
		html_tag("</table></td></tr>\n");
		html_tag("<tr><td>&nbsp;</td></tr> \n");
		html_tag("<tr><td>&nbsp;</td></tr> \n");
	}
	else
	{
		html_tag("<tr><td>&nbsp;</td></tr> \n");
	}
#endif


	switch(s_html_cfg_eqpmt.s_gene.u8_mode_radio_modem)
	{
		case MODE_RADIO_MODEM_STATION:
			html_tag("<tr><td><P class=undermenu>&nbsp;</P></td></tr> \n");
			html_tag("<tr><td>&nbsp;</td></tr> \n");
			html_tag("<tr><td><table align=center border=\"0\"> \n");
			//Statut de la connexion
			html_tag("	<tr>\n");
			html_tag("		<td nowrap><B>%s</B></td>\n",
					 pt_tb_msg[u8_html_langue].ps8_msg_statut);
			html_tag("		<td><B>:</B></td>\n");
			html_tag("		<td>&nbsp;<span id=SPAN_STATUT>%s</span></td>\n",
					 pt_tb_msg[u8_html_langue].ps8_msg_choix_station_connexion[s_html_exploit.s_station.u8_statut_connexion]);
			html_tag("	</tr>\n");
			//BSSID
			html_tag("	<tr>\n");
			html_tag("		<td nowrap><B>%s</B></td>\n",
					 pt_tb_msg[u8_html_langue].ps8_msg_BSSID);
			html_tag("		<td><B>:</B></td>\n");
			if(STATUT_CONNEXION__ASSOCIATED == s_html_exploit.s_station.u8_statut_connexion)
			{
				html_tag("		<td>&nbsp;<span id=SPAN_BSSID>%s</span></td>\n",
						 ps8GetChAddressMac(s_html_exploit.s_station.pu8_bssid_add_mac));
			}
			else
			{
				html_tag("		<td>&nbsp;<span id=SPAN_BSSID>?</span></td>\n");
			}
			html_tag("	</tr>\n");
			//ESSID
			html_tag("	<tr>\n");
			html_tag("		<td nowrap><B>%s</B></td>\n",
					 pt_tb_msg[u8_html_langue].ps8_msg_SSID);
			html_tag("		<td><B>:</B></td>\n");
			html_tag("		<td>&nbsp;<span id=SPAN_ESSID>%s</span></td>\n",s_html_exploit.s_station.ps8_ssid_inprogress);
			html_tag("	</tr>\n");
#ifdef _WRM100_N_SELECT
			//Canal utilisé
			html_tag("	<tr>\n");
			html_tag("		<td nowrap><B>%s</B></td>\n",
					 pt_tb_msg[u8_html_langue].ps8_msg_canal_utilise);
			html_tag("		<td><B>:</B></td>\n");
			if(CHANNEL_RADIO_DISABLED != s_html_exploit.s_station.u16_channel_inprogress)
			{
				html_tag("		<td>&nbsp;<span id=SPAN_CHANNEL>%d MHz - CH=%d</span></td>\n",
						 s_html_exploit.s_station.u16_freq_MHz_inprogress,
						 s_html_exploit.s_station.u16_channel_inprogress);
			}
			else
			{
				html_tag("		<td>&nbsp;<span id=SPAN_CHANNEL>? MHz - CH=?</span></td>\n");
			}
			html_tag("	</tr>\n");
#endif
			//RSSI
			html_tag("	<tr>\n");
			html_tag("		<td nowrap><B>%s</B></td>\n",
					 pt_tb_msg[u8_html_langue].ps8_msg_RSSI);
			html_tag("		<td><B>:</B></td>\n");
			if(STATUT_CONNEXION__ASSOCIATED == s_html_exploit.s_station.u8_statut_connexion)
			{
				html_tag("		<td>&nbsp;<span id=SPAN_RSSI>%ld dBm</span></td>\n",
						 s_html_exploit.s_station.s32_rssi_dbm);
			}
			else
			{
				html_tag("		<td>&nbsp;<span id=SPAN_RSSI>? dBm</span></td>\n");
			}
			html_tag("	</tr>\n");
			html_tag("</table></td></tr>\n");
			break;
		case MODE_RADIO_MODEM_ACCESS_POINT:
			html_tag("<tr><td><P class=undermenu>&nbsp;</P></td></tr> \n");
			html_tag("<tr><td><table align=center border=\"0\"> \n");
			//Adresse MAC WLAN
			html_tag("	<tr>\n");
			html_tag("		<td nowrap><B>%s</B></td>\n",
					 pt_tb_msg[u8_html_langue].ps8_msg_adresse_mac_wifi);
			html_tag("		<td><B>:</B></td>\n");
			html_tag("		<td>&nbsp;%s</td>\n",
					 ps8GetChAddressMac(s_html_exploit.s_general.ps_interface[INTERFACE_WLAN].pu8_add_mac));
			html_tag("	</tr>\n");
			//ESSID
			html_tag("	<tr>\n");
			html_tag("		<td nowrap><B>%s</B></td>\n",
					 pt_tb_msg[u8_html_langue].ps8_msg_SSID);
			html_tag("		<td><B>:</B></td>\n");
			html_tag("		<td>&nbsp;<span id=SPAN_ESSID>%s</span></td>\n",
					 s_html_cfg_eqpmt.s_wifi.ps8_ssid_primary);
			html_tag("	</tr>\n");
#ifdef _WRM100_N_SELECT
			//Canal utilisé
			html_tag("	<tr>\n");
			html_tag("		<td nowrap><B>%s</B></td>\n",
					 pt_tb_msg[u8_html_langue].ps8_msg_canal_utilise);
			html_tag("		<td><B>:</B></td>\n");
			if(CHANNEL_RADIO_DISABLED != s_html_exploit.s_access_point.u16_channel_inprogress)
			{
				html_tag("		<td>&nbsp;<span id=SPAN_CHANNEL>%d MHz - CH=%d</span></td>\n",
						 s_html_exploit.s_access_point.u16_freq_MHz_inprogress,
						 s_html_exploit.s_access_point.u16_channel_inprogress);
			}
			else
			{
				html_tag("		<td>&nbsp;<span id=SPAN_CHANNEL>? MHz - CH=?</span></td>\n");
			}
			html_tag("	</tr>\n");
#endif
			html_tag("</table></td></tr>\n");
			
			html_tag("<tr><td><P class=undermenu>%s</P></td></tr> \n",
					 pt_tb_msg[u8_html_langue].ps8_msg_liste_clients_wifi_associes);
						
			html_tag("<tr><td>&nbsp;</td></tr> \n");
			html_tag("<tr><td>\n");
			html_tag("<pre>");
			HtmlPrint_TableClientWifi();
			html_tag("</pre>\n");
			html_tag("</td></tr> \n");
			break;
		case MODE_RADIO_MODEM_MONITOR:
			break;
		default:
			break;
	}


	html_tag("<tr><td>&nbsp;</td></tr> \n");
	html_tag("</table> \n");
	html_tag("</body> \n");
	html_tag("</html> \n");

}/*VExploitWireless*/

//=====================================================================================
// Fonction		: HtmlPrint_TableClientWifi
// Entrees		: rien
// Sortie		: rien
// Auteur		: CM - 04/11/2009
// Description	: Code HTML de la table des clients Wifi
//=====================================================================================
void HtmlPrint_TableClientWifi(void)
{
	u16sod loc_u16_i;

	sprintf(ps8_html_string,"%s (dBm)",pt_tb_msg[u8_html_langue].ps8_msg_RSSI);
	html_tag("<B>%-30s%-20s%-30s</B>\n",
			 pt_tb_msg[u8_html_langue].ps8_msg_adresse_MAC,
			 ps8_html_string,
			 pt_tb_msg[u8_html_langue].ps8_msg_statut);
	
	for(loc_u16_i=0;loc_u16_i<NB_ASSOCIATED_STATIONS_MAX;loc_u16_i++)
	{
		if(TRUE == s_html_exploit.s_access_point.s_wifi_client[loc_u16_i].u8_present)
		{
			html_tag("<span id=SPAN_WIFI%s>",ps8GetChAddressMac(s_html_exploit.s_access_point.s_wifi_client[loc_u16_i].pu8_add_mac));
			html_tag("%-30s%-20ld%s",
					 ps8GetChAddressMac(s_html_exploit.s_access_point.s_wifi_client[loc_u16_i].pu8_add_mac),
					 s_html_exploit.s_access_point.s_wifi_client[loc_u16_i].s32_rssi_dbm,
					 ps8GetChStatutClientWifi(s_html_cfg_eqpmt.s_wifi.u8_mode_securite_wifi, s_html_exploit.s_access_point.s_wifi_client[loc_u16_i].u32_statut, u8_html_langue));
			html_tag("</span> \n");
		}
	}
	
	
	//On surveille le nombre de clients wifi associés
	html_tag("<span id=SPAN_NB_CLIENTS_WIFI_%d></span> \n",
			 s_html_exploit.s_access_point.u16_nb_associations);

}/*HtmlPrint_TableClientWifi*/

/*_____VI - PROCEDURE D'INITIALISATION ___________________________________*/

//=====================================================================================
// Fonction		: InitModule_VExploitWireless
// Entrees		: rien
// Sortie		: rien
// Auteur		: CM - 26/10/2009
// Description	: Initialisation du module de vexploitWireless
//=====================================================================================
void InitModule_VExploitWireless(void)
{
}/*InitModule_VExploitWireless*/
