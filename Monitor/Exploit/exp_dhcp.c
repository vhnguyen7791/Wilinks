/*========================================================================*/
/* NOM DU FICHIER  : exp_dhcp.c	 		                                  */
/*========================================================================*/
/* Compilateur     : GCC                                                  */
/* Linking locator : GCC                                                  */
/* Formatter       : GCC                                                  */
/* Auteur          : CM                                                   */
/* Date			   : 18/01/2010                                           */
/* Libelle         : Monitor: exploitation du serveur / relai DHCP		  */
/* Projet          : WRM100                                               */
/* Indice          : BE024                                                */
/*========================================================================*/
/* Historique      :                                                      */
//BE005 15/01/2010 CM
// - CREATION
//BE014 08/03/2010 CM
// - Modification gestion de l'exploitation
//	=> toute l'exploitation est calculée dans le processus 'monitor'.
//BE024 03/04/2010 CM
// - Correction suite revue de codage de Caf (sur BE023)
/*========================================================================*/

/*_____I - COMMENTAIRES - DEFINITIONS -  REMARQUES _______________________*/

/*_____II - DEFINE SBIT __________________________________________________*/
#define _EXP_DHCP

//Exploitation serveur DHCP
#define NB_DATABINARY_CLIENT_DHCP_LEASE	24		//octets

//Fichier temporaire (copie du fichier udhcpd.leases)
#define FICHIER_UDHCPD_TMP_LEASES	PATH_DIR_VAR "lib/misc/udhcpd.tmp.leases"

/*_____III - INCLUDE - DIRECTIVES ________________________________________*/
#include "../headers.h"


/*_____IV - VARIABLES GLOBALES ___________________________________________*/


/*_____V - PROCEDURES ____________________________________________________*/

//=====================================================================================
// Fonction		: u8MajDhcpClient
// Entrees		: <loc_ps_exploit<: exploitation (RAM) pour ce processus
//				: <loc_ps_exp_clientdhcp<: client dhcp
// Sortie		: <loc_u8_resultat>: TRUE, si OK, sinon FALSE
// Auteur		: CM - 18/01/2010 -
// Description	: Mise à jour d'un client (Ajout d'un client DHCP si ce client n'existe pas)
//=====================================================================================
u8sod u8MajDhcpClient(S_STRUCT_EXPLOITATION *loc_ps_exploit, S_STRUCT_EXP_CLIENT_DHCP *loc_ps_exp_clientdhcp)
{
	u8sod	loc_u8_resultat;
	u16sod	loc_u16_i;
	u16sod	loc_u16_idx_client;
	u8sod	loc_u8_trouve;

	loc_u8_resultat = FALSE;	//INIT
	loc_u8_trouve = FALSE; //INIT
	loc_u16_idx_client = 0;	//INIT

	//Recherche si ce client existe dans la base de données d'exploitation
	for(loc_u16_i=0;loc_u16_i<NB_MAX_CLIENTS_DHCP;loc_u16_i++)
	{
		if(TRUE == loc_ps_exploit->s_dhcp.s_client_connected[loc_u16_i].u8_present)//CONDITION: client DHCP présent dans la bdd exploit
		{
			if(0 == memcmp(loc_ps_exp_clientdhcp->pu8_add_mac, loc_ps_exploit->s_dhcp.s_client_connected[loc_u16_i].pu8_add_mac, ETHER_ADDR_LEN))
			{
//				printf("client trouve[%d]\n",loc_u16_i);
				//client trouvé
				loc_u16_idx_client = loc_u16_i;
				loc_u8_trouve = TRUE;
				loc_u16_i = NB_MAX_CLIENTS_DHCP + 1;	//on sort
			}
		}
	}

	if((TRUE == loc_u8_trouve)&&(loc_u16_idx_client<NB_MAX_CLIENTS_DHCP)) //CONDITION: client déjà présent
	{
		//donc maj des données du client
		loc_ps_exploit->s_dhcp.s_client_connected[loc_u16_idx_client] = *loc_ps_exp_clientdhcp; //MAJ
		loc_u8_resultat = TRUE;
	}
	else //CONDITION: nouveau client
	{
		//il faut ajouter ce client dans la bdd
		
		//Recherche si il y a de la place pour ajouter le nouveau client
		for(loc_u16_i=0;loc_u16_i<NB_MAX_CLIENTS_DHCP;loc_u16_i++)
		{
			if(FALSE == loc_ps_exploit->s_dhcp.s_client_connected[loc_u16_i].u8_present)//CONDITION: client DHCP présent dans la bdd exploit
			{
				loc_ps_exploit->s_dhcp.s_client_connected[loc_u16_i] = *loc_ps_exp_clientdhcp; //MAJ
				loc_u16_i = NB_MAX_CLIENTS_DHCP+1; //on sort
				loc_u8_resultat = TRUE;
			}
		}
		
	}
	
	return loc_u8_resultat;
}/*u8MajDhcpClient*/

//=====================================================================================
// Fonction		: ExtractExploitDHCPServer
// Entrees		: <loc_ps_config< : configuration (RAM) pour ce processus
//				: <loc_ps_exploit<: exploitation (RAM) pour ce processus
// Sortie		: rien
// Auteur		: CM - 18/01/2010 -
// Description	: extraction exploitation serveur DHCP
//=====================================================================================
void ExtractExploitDHCPServer(S_STRUCT_CONFIGURATION *loc_ps_config, S_STRUCT_EXPLOITATION *loc_ps_exploit)
{
	u8sod	loc_u8_boucle;
	FILE	*loc_p_handle;
	u8sod	loc_u8_i;
	u8sod	loc_pu8_buffer[NB_DATABINARY_CLIENT_DHCP_LEASE];
	S_STRUCT_EXP_CLIENT_DHCP	loc_s_clientdhcp;
	union 
	{
		u8sod		pu8_term[4];
		u32sod		u32_term;
	} loc_u_tempo32bit;
	u16sod loc_u16_cpt_boucle;

	loc_u8_boucle = TRUE;	//INIT
	loc_p_handle = NULL; //INIT
	memset(&loc_s_clientdhcp, 0, sizeof(S_STRUCT_EXP_CLIENT_DHCP)); //INIT
	loc_u16_cpt_boucle = 0; //INIT

	//On copie d'abord le fichier udhcpd.leases dans un fichier temporaire
	u8CmdSystem_CopyFile(FICHIER_UDHCPD_LEASES, FICHIER_UDHCPD_TMP_LEASES);

	if(NULL != (loc_p_handle = fopen(FICHIER_UDHCPD_TMP_LEASES, "rb" ))) //CONDITION: fichier présent
	{
		loc_u8_boucle = TRUE;	//RAZ
		do{
			if (NB_DATABINARY_CLIENT_DHCP_LEASE == fread(&loc_pu8_buffer, sizeof(u8sod), NB_DATABINARY_CLIENT_DHCP_LEASE, loc_p_handle))
			{
				memset(&loc_s_clientdhcp, 0, sizeof(S_STRUCT_EXP_CLIENT_DHCP)); //INIT
				//16 premiers octets: adresse MAC
				for(loc_u8_i=0;loc_u8_i<ETHER_ADDR_LEN;loc_u8_i++)
				{
					loc_s_clientdhcp.pu8_add_mac[loc_u8_i] = loc_pu8_buffer[loc_u8_i];
				}
				//4 octets suivants: adresse IP
				loc_u_tempo32bit.pu8_term[0] = loc_pu8_buffer[16]; //MSB
				loc_u_tempo32bit.pu8_term[1] = loc_pu8_buffer[17];
				loc_u_tempo32bit.pu8_term[2] = loc_pu8_buffer[18];
				loc_u_tempo32bit.pu8_term[3] = loc_pu8_buffer[19]; //LSB
				loc_s_clientdhcp.u32_adresse_ip = loc_u_tempo32bit.u32_term;
				//4 octets suivants: temps restant du bail
				loc_u_tempo32bit.pu8_term[0] = loc_pu8_buffer[20];	//MSB
				loc_u_tempo32bit.pu8_term[1] = loc_pu8_buffer[21];
				loc_u_tempo32bit.pu8_term[2] = loc_pu8_buffer[22];
				loc_u_tempo32bit.pu8_term[3] = loc_pu8_buffer[23];	//LSB
				loc_s_clientdhcp.u32_temps_restant = ntohl(loc_u_tempo32bit.u32_term);
				loc_s_clientdhcp.u8_present = TRUE; //toujours présent
				loc_s_clientdhcp.u8_flag_maj = TRUE; //toujours présent
//				printf("Client:MAC=%s IP=%s Tmps=%d\n",
//					   ps8GetChAddressMac(loc_s_clientdhcp.pu8_add_mac),
//					   ps8GetStringIp(loc_s_clientdhcp.u32_adresse_ip),
//					   loc_s_clientdhcp.u32_temps_restant);

				if(FALSE == u8MajDhcpClient(loc_ps_exploit, &loc_s_clientdhcp))
				{
					printf("ExtractExploitDHCPServer: Probleme u8MajDhcpClient\n");
				}
			}
			else
			{
				//on sort
				loc_u8_boucle = FALSE;
			}
			loc_u16_cpt_boucle ++;

		}while((TRUE == loc_u8_boucle)&&
			   (loc_u16_cpt_boucle < NB_MAX_CLIENTS_DHCP)
			  );

		//fermeture du fichier
		fclose(loc_p_handle);
	}

}/*ExtractExploitDHCPServer*/

//=====================================================================================
// Fonction		: GestionExploitDHCPServer
// Entrees		: <loc_ps_config< : configuration (RAM) pour ce processus
//				: <loc_ps_exploit<: exploitation (RAM) pour ce processus
// Sortie		: rien
// Auteur		: CM - 18/01/2010 -
// Description	: gestion exploitation serveur DHCP
//=====================================================================================
void GestionExploitDHCPServer(S_STRUCT_CONFIGURATION *loc_ps_config, S_STRUCT_EXPLOITATION *loc_ps_exploit)
{
	u16sod	loc_u16_nb_clientsdhcp;
	u16sod	loc_u16_i;

	loc_u16_nb_clientsdhcp = 0;	//INIT

	if(TRUE == u8FillExploitDHCPFile(&loc_ps_exploit->s_dhcp))
	{
		//On resete l'info qui signale que le client a été mis à jour
		for(loc_u16_i=0;loc_u16_i<NB_MAX_CLIENTS_DHCP;loc_u16_i++)
		{
			loc_ps_exploit->s_dhcp.s_client_connected[loc_u16_i].u8_flag_maj = FALSE; //RAZ
		}

		//Puis on extrait et mise à jour des clients DHCP
		ExtractExploitDHCPServer(loc_ps_config, loc_ps_exploit);

		//On resete les clients qui n'ont pas été maj
		for(loc_u16_i=0;loc_u16_i<NB_MAX_CLIENTS_DHCP;loc_u16_i++)
		{
			if(FALSE == loc_ps_exploit->s_dhcp.s_client_connected[loc_u16_i].u8_flag_maj)//CONDITION: maj non effectué du client DHCP
			{
				//on le supprime de la bdd exploit
				InitExpDhcpClientOfServer(&loc_ps_exploit->s_dhcp.s_client_connected[loc_u16_i]); //RAZ
			}
		}

		//On compte le nombre de clients DHCP
		loc_u16_nb_clientsdhcp = 0;	//RAZ
		for(loc_u16_i=0;loc_u16_i<NB_MAX_CLIENTS_DHCP;loc_u16_i++)
		{
			if(TRUE == loc_ps_exploit->s_dhcp.s_client_connected[loc_u16_i].u8_present)//CONDITION: mémoire disponible pour client DHCP 
			{
				loc_u16_nb_clientsdhcp ++;
			}
		}
		loc_ps_exploit->s_dhcp.u16_nb_clients = loc_u16_nb_clientsdhcp; //MAJ

		//On gère le flag qui signale que le serveur DHCP peut ne pas allouer d'adresse IP
		if((u32sod)loc_u16_nb_clientsdhcp >= (loc_ps_config->s_gene.u32_lan_dhcpsrv_ip_max - loc_ps_config->s_gene.u32_lan_dhcpsrv_ip_min))
		{
			loc_ps_exploit->s_dhcp.u8_server_dhcp_full = TRUE;
		}
		else
		{
			loc_ps_exploit->s_dhcp.u8_server_dhcp_full = FALSE;
		}
		

		//Puis sauvegarde
		u8EditExploitDHCPFile(&loc_ps_exploit->s_dhcp);
	}
	

}/*GestionExploitDHCPServer*/


/*_____VII - PROCEDURE D'INITIALISATION __________________________________*/

//=====================================================================================
// Fonction		: InitModule_Exp_Dhcp
// Entrees		: rien
// Sortie		: rien
// Auteur		: CM - 18/01/2010 -
// Description	: Initialisation du module de exp_dhcp
//=====================================================================================
void InitModule_Exp_Dhcp(void)
{
	
}/*InitModule_Exp_Dhcp*/

