/*========================================================================*/
/* NOM DU FICHIER  : exp_network.c 		                                  */
/*========================================================================*/
/* Compilateur     : GCC                                                  */
/* Linking locator : GCC                                                  */
/* Formatter       : GCC                                                  */
/* Auteur          : CM                                                   */
/* Date			   : 18/01/2010                                           */
/* Libelle         : Monitor: exploitation du network					  */
/* Projet          : WRM100                                               */
/* Indice          : BE058                                                */
/*========================================================================*/
/* Historique      :                                                      */
//BE005 15/01/2010 CM
// - CREATION
//BE010 03/02/2010 CM
// - Ajout information statut IP des interfaces
//BE014 08/03/2010 CM
// - Modification gestion de l'exploitation
//	=> toute l'exploitation est calculée dans le processus 'monitor'.
//BE037 06/07/2010 CM
// - Ajout récupération statut ethernet des 2 ports ethernet
//BE046 17/11/2010 CM
// - Correction alarme Ethernet pour chaque accès
//	alarme ethernet lan 1 et alarme ethernet lan 2
//	L'alarme "ethernet lan 2" est non validée par défaut
//	+ aussi disponible sur ACCESS POINT
// - Ajout debounce des alarmes ethernet
//	car alarme à tort quand traffic important sur STATION
//BE048 29/11/2010 CM
// - Correction statut IP (Succès DHCP non affiché) en bridge
//BE054 11/01/2011 CM
// - Ajout gestion mode monitor
//BE058 21/01/2011 CM
// - AJout fonction arret AP si ethernet deconnecte
/*========================================================================*/

/*_____I - COMMENTAIRES - DEFINITIONS -  REMARQUES _______________________*/

/*_____II - DEFINE SBIT __________________________________________________*/
#define _EXP_NETWORK

//Debounce alarmes ethernet
#define TIMEOUT_DEBOUNCE_ETHERNET	3	//secondes

/*_____III - INCLUDE - DIRECTIVES ________________________________________*/
#include "../headers.h"


/*_____IV - VARIABLES GLOBALES ___________________________________________*/

//Debounce alarmes ethernet
static u16sod u16_cpt_debounce_ethernet[NB_MAX_PORTS_ETHERNET];

/*_____V - PROCEDURES ____________________________________________________*/


//=====================================================================================
// Fonction		: MiseAjour_ExploitAdressMAC
// Entrees		: <loc_ps_exploit<: exploitation (RAM) pour ce processus
// Sortie		: rien
// Auteur		: CM - 24/09/2009 -
// Description	: Mise à jour adresse MAC des interfaces
//=====================================================================================
void MiseAjour_ExploitAdressMAC(S_STRUCT_EXPLOITATION *loc_ps_exploit)
{
	if(TRUE == u8FillExploitGeneralFile(&loc_ps_exploit->s_general))
	{
		if(FALSE == u8GetMacAddress(NOM_INTERFACE_ETHERNET,loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].pu8_add_mac))
		{
			printf("MiseAjour_ExploitAdressMAC %s KO\n",NOM_INTERFACE_ETHERNET);
			loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].u8_presence = FALSE;
		}
		else
		{
			loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].u8_presence = TRUE;
		}

		if(FALSE == u8GetMacAddress(NOM_INTERFACE_WIFI,loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].pu8_add_mac))
		{
			printf("MiseAjour_ExploitAdressMAC %s KO\n",NOM_INTERFACE_WIFI);
			loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].u8_presence = FALSE;
		}
		else
		{
			loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].u8_presence = TRUE;
		}
		u8EditExploitGeneralFile(&loc_ps_exploit->s_general);
	}

}/*MiseAjour_ExploitAdressMAC*/

//=====================================================================================
// Fonction		: u8MiseAjour_ExploitInterfaces
// Entrees		: <loc_ps_config< : configuration (RAM) pour ce processus
//				: <loc_ps_exploit<: exploitation (RAM) pour ce processus
// Sortie		: <loc_u8_chgt>: TRUE si chgt des infos exploit, sinon FALSE
// Auteur		: CM - 27/01/2010 -
// Description	: Mise à jour exploitation des interfaces
//=====================================================================================
u8sod u8MiseAjour_ExploitInterfaces(S_STRUCT_CONFIGURATION *loc_ps_config, S_STRUCT_EXPLOITATION *loc_ps_exploit)
{
	u8sod	loc_u8_chgt;
	s8sod	loc_ps8_add_ip	[MAX_LG_FORMAT_ADRESSE_IP + 1];
	s8sod	loc_ps8_mask	[MAX_LG_FORMAT_ADRESSE_IP + 1];
	u8sod	loc_u8_link_status;
	u8sod	loc_u8_i;

	loc_u8_chgt = FALSE; //INIT
	strcpy(loc_ps8_add_ip, ""); //INIT
	strcpy(loc_ps8_mask, ""); //INIT
	loc_u8_link_status = FALSE;	//INIT

	switch(loc_ps_config->s_gene.u8_mode_radio_modem)
	{
		case MODE_RADIO_MODEM_ACCESS_POINT:
		case MODE_RADIO_MODEM_MONITOR:
			//On lit les adresses IP sur le bridge
			if(FALSE == u8GetIPAddress(NOM_INTERFACE_BRIDGE, loc_ps8_add_ip, loc_ps8_mask))
			{
				;
//				printf("u8MiseAjour_ExploitInterfaces %s KO\n",NOM_INTERFACE_ETHERNET);
			}
			//On test si il y a un changement
			if((0 != strcmp(loc_ps8_add_ip, loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].ps8_add_ip))||
			   (0 != strcmp(loc_ps8_mask, loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].ps8_mask))||
			   (0 != strcmp(loc_ps8_add_ip, loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].ps8_add_ip))||
			   (0 != strcmp(loc_ps8_mask, loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].ps8_mask))||
			   (loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].u8_statut_ip != u8GetAutoStatutIP_Interface(INTERFACE_BRIDGE))
			  )
			{
				//Les adresses IP LAN et WLAN sont identiques
				strcpy(loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].ps8_add_ip, loc_ps8_add_ip);
				strcpy(loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].ps8_mask, loc_ps8_mask);
				strcpy(loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].ps8_add_ip, loc_ps8_add_ip);
				strcpy(loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].ps8_mask, loc_ps8_mask);
				loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].u8_statut_ip = u8GetAutoStatutIP_Interface(INTERFACE_BRIDGE);
				loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].u8_statut_ip = u8GetAutoStatutIP_Interface(INTERFACE_BRIDGE);
				loc_u8_chgt = TRUE;
			}
			break;
		case MODE_RADIO_MODEM_STATION:
			switch(loc_ps_config->s_gene.u8_mode_network)
			{
				case MODE_NETWORK_BRIDGE:
					//On lit les adresses IP sur le bridge
					if(FALSE == u8GetIPAddress(NOM_INTERFACE_BRIDGE, loc_ps8_add_ip, loc_ps8_mask))
					{
						;
//						printf("u8MiseAjour_ExploitInterfaces %s KO\n",NOM_INTERFACE_ETHERNET);
					}
					//On test si il y a un changement
					if((0 != strcmp(loc_ps8_add_ip, loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].ps8_add_ip))||
					   (0 != strcmp(loc_ps8_mask, loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].ps8_mask))||
					   (0 != strcmp(loc_ps8_add_ip, loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].ps8_add_ip))||
					   (0 != strcmp(loc_ps8_mask, loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].ps8_mask)) ||
					   (loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].u8_statut_ip != u8GetAutoStatutIP_Interface(INTERFACE_BRIDGE))
					  )
					{
						//Les adresses IP LAN et WLAN sont identiques
						strcpy(loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].ps8_add_ip, loc_ps8_add_ip);
						strcpy(loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].ps8_mask, loc_ps8_mask);
						strcpy(loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].ps8_add_ip, loc_ps8_add_ip);
						strcpy(loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].ps8_mask, loc_ps8_mask);
						loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].u8_statut_ip = u8GetAutoStatutIP_Interface(INTERFACE_BRIDGE);
						loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].u8_statut_ip = u8GetAutoStatutIP_Interface(INTERFACE_BRIDGE);
						loc_u8_chgt = TRUE;
					}
					break;
				case MODE_NETWORK_ROUTER:
					//On lit l'adresse IP sur l'accès LAN
					if(FALSE == u8GetIPAddress(NOM_INTERFACE_ETHERNET, loc_ps8_add_ip, loc_ps8_mask))
					{
						;
//							printf("u8MiseAjour_ExploitInterfaces %s KO\n",NOM_INTERFACE_ETHERNET);
					}
					//On test si il y a un changement
					if((0 != strcmp(loc_ps8_add_ip, loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].ps8_add_ip))||
					   (0 != strcmp(loc_ps8_mask, loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].ps8_mask)) ||
					   (loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].u8_statut_ip != STATUT_IP__STATIC)
					  )
					{
						strcpy(loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].ps8_add_ip, loc_ps8_add_ip);
						strcpy(loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].ps8_mask, loc_ps8_mask);
						loc_ps_exploit->s_general.ps_interface[INTERFACE_LAN].u8_statut_ip = STATUT_IP__STATIC;
						loc_u8_chgt = TRUE;
					}

					//On lit l'adresse IP sur l'accès LAN
					if(FALSE == u8GetIPAddress(NOM_INTERFACE_WIFI, loc_ps8_add_ip, loc_ps8_mask))
					{
						;
//							printf("u8MiseAjour_ExploitInterfaces %s KO\n",NOM_INTERFACE_WIFI);
					}
					//On test si il y a un changement
					if((0 != strcmp(loc_ps8_add_ip, loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].ps8_add_ip))||
					   (0 != strcmp(loc_ps8_mask, loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].ps8_mask)) ||
					   (loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].u8_statut_ip != u8GetAutoStatutIP_Interface(INTERFACE_WLAN))
					  )
					{
						strcpy(loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].ps8_add_ip, loc_ps8_add_ip);
						strcpy(loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].ps8_mask, loc_ps8_mask);
						loc_ps_exploit->s_general.ps_interface[INTERFACE_WLAN].u8_statut_ip = u8GetAutoStatutIP_Interface(INTERFACE_WLAN);
						loc_u8_chgt = TRUE;
					}
					break;
				default:
					break;
			}
			break;
		default:
			break;
	}

	//Calcul statut ethernet (station / access point)
	for(loc_u8_i=0;loc_u8_i<NB_MAX_PORTS_ETHERNET;loc_u8_i++)
	{
		loc_u8_link_status = u8GetEthernetLinkStatus(loc_u8_i);
		if(FALSE == loc_u8_link_status) //CONDITION: non connecté (il faut debouncé)
		{
			if(u16_cpt_debounce_ethernet[loc_u8_i] < TIMEOUT_DEBOUNCE_ETHERNET) //CONDITION: on debounce
			{
				u16_cpt_debounce_ethernet[loc_u8_i]++;
			}
			else //CONDITION: timeout expire
			{
				if(loc_ps_exploit->s_general.u8_link_statut_ethernet[loc_u8_i] != loc_u8_link_status) //CONDITION: changement statut
				{
					loc_ps_exploit->s_general.u8_link_statut_ethernet[loc_u8_i] = loc_u8_link_status;
					loc_u8_chgt = TRUE;
				}
			}
		}
		else
		{
			u16_cpt_debounce_ethernet[loc_u8_i] = 0;	//RAZ
			if(loc_ps_exploit->s_general.u8_link_statut_ethernet[loc_u8_i] != loc_u8_link_status) //CONDITION: changement statut
			{
				loc_ps_exploit->s_general.u8_link_statut_ethernet[loc_u8_i] = loc_u8_link_status;
				loc_u8_chgt = TRUE;
			}
		}
	}
	

	return loc_u8_chgt;
}/*u8MiseAjour_ExploitInterfaces*/


/*_____VII - PROCEDURE D'INITIALISATION __________________________________*/

//=====================================================================================
// Fonction		: InitModule_Exp_Network
// Entrees		: rien
// Sortie		: rien
// Auteur		: CM - 18/01/2010 -
// Description	: Initialisation du module de exp_network
//=====================================================================================
void InitModule_Exp_Network(void)
{
	u8sod loc_u8_i;

	for(loc_u8_i=0;loc_u8_i<NB_MAX_PORTS_ETHERNET;loc_u8_i++)
	{
		u16_cpt_debounce_ethernet[loc_u8_i] = 0;	//INIT
	}
	
}/*InitModule_Exp_Network*/

