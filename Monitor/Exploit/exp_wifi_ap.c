/*========================================================================*/
/* NOM DU FICHIER  : exp_wifi_ap.c	 		                              */
/*========================================================================*/
/* Compilateur     : GCC                                                  */
/* Linking locator : GCC                                                  */
/* Formatter       : GCC                                                  */
/* Auteur          : CM                                                   */
/* Date			   : 26/01/2010                                           */
/* Libelle         : Monitor: exploitation du wifi (ACCESS POINT)		  */
/* Projet          : WRM100                                               */
/* Indice          : BE060                                                */
/*========================================================================*/
/* Historique      :                                                      */
//BE007 26/01/2010 CM
// - CREATION
//BE010 03/02/2010 CM
// - Correction BUG statut des clients Wifi erroné (en mode non sécurisé)
//		-> affiche "non associé" au lieu de "associé"
//BE014 08/03/2010 CM
// - Modification gestion de l'exploitation
//	=> toute l'exploitation est calculée dans le processus 'monitor'.
// - Modification demande du fichier hostapd.dump
//			=> demande pour la prochaine seconde
// - Ajout option compilation "-Wall" + correction w@rning
//BE024 03/04/2010 CM
// - Correction suite revue de codage de Caf (sur BE023)
//BE040 13/09/2010 CM
// - Nouveaux projets WRM100
//BE053 16/12/2010 CM
// - Correction bug commande pidof via hostapd
//BE058 21/01/2011 CM
// - Ajout dans exploitation du canal en cours (sur AP et STA)
//BE060 16/03/2011
// - DEP: Ajout des évenements de connexion et déconnexion d'une STATION
// - Correction bug lors de l'exploitation hostapd.dump quand nombreuses stations connectées
/*========================================================================*/

/*_____I - COMMENTAIRES - DEFINITIONS -  REMARQUES _______________________*/

/*_____II - DEFINE SBIT __________________________________________________*/
#define _EXP_WIFI_AP

#define TAILLE_MAX_LIGNE_HOSTAPD_DUMP	200

/*_____III - INCLUDE - DIRECTIVES ________________________________________*/
#include "../headers.h"

/*_____IV - VARIABLES GLOBALES ___________________________________________*/


/*_____V - PROCEDURES ____________________________________________________*/

//=====================================================================================
// Fonction		: u8MajDonneesClientWifi
// Entrees		: <loc_ps_exp_accesspoint<: exploitation (RAM) pour ce processus
//				: <loc_ps_exp_wifi_client<: info du client wifi
// Sortie		: <loc_u8_resultat>: TRUE, si OK, sinon FALSE
// Auteur		: CM - 26/01/2010 -
// Description	: Mise à jour du client Wifi (Ajout du client Wifi si ce client n'existe pas)
//=====================================================================================
u8sod u8MajDonneesClientWifi(S_STRUC_EXP_ACCESS_POINT *loc_ps_exp_accesspoint, S_STRUCT_EXP_WIFI_CLIENT *loc_ps_exp_wifi_client)
{
	u8sod	loc_u8_resultat;
	u16sod	loc_u16_i;
	u16sod	loc_u16_idx_client;
	u8sod	loc_u8_trouve;

	loc_u8_resultat = FALSE;	//INIT
	loc_u8_trouve = FALSE; //INIT
	loc_u16_idx_client = 0;	//INIT

	//Recherche si ce client existe dans la base de données d'exploitation
	for(loc_u16_i=0;loc_u16_i<NB_ASSOCIATED_STATIONS_MAX;loc_u16_i++)
	{
		if(TRUE == loc_ps_exp_accesspoint->s_wifi_client[loc_u16_i].u8_present)//CONDITION: client Wifi présent dans la bdd exploit
		{
			if(0 == memcmp(loc_ps_exp_wifi_client->pu8_add_mac, loc_ps_exp_accesspoint->s_wifi_client[loc_u16_i].pu8_add_mac, ETHER_ADDR_LEN))
			{
//				printf("client trouve[%d]\n",loc_u16_i);
				//client trouvé
				loc_u16_idx_client = loc_u16_i;
				loc_u8_trouve = TRUE;
				loc_u16_i = NB_ASSOCIATED_STATIONS_MAX + 1;	//on sort
			}
		}
	}

	if((TRUE == loc_u8_trouve)&&(loc_u16_idx_client<NB_ASSOCIATED_STATIONS_MAX)) //CONDITION: client déjà présent
	{
		//donc maj des données du client
		loc_ps_exp_accesspoint->s_wifi_client[loc_u16_idx_client] = *loc_ps_exp_wifi_client; //MAJ
		loc_u8_resultat = TRUE;
	}
	else //CONDITION: nouveau client
	{
		//il faut ajouter ce client dans la bdd

		//Recherche si il y a de la place pour ajouter le nouveau client
		for(loc_u16_i=0;loc_u16_i<NB_ASSOCIATED_STATIONS_MAX;loc_u16_i++)
		{
			if(FALSE == loc_ps_exp_accesspoint->s_wifi_client[loc_u16_i].u8_present)//CONDITION: mémoire disponible pour client Wifi
			{
				loc_ps_exp_accesspoint->s_wifi_client[loc_u16_i] = *loc_ps_exp_wifi_client; //MAJ
				loc_u16_i = NB_ASSOCIATED_STATIONS_MAX+1; //on sort
				loc_u8_resultat = TRUE;
			}
		}
	}

	return loc_u8_resultat;
}/*u8MajDonneesClientWifi*/

//=====================================================================================
// Fonction		: u8MajStatutClientWifi
// Entrees		: <loc_ps_exp_accesspoint<: exploitation (RAM) pour ce processus
//				: <loc_ps_exp_wifi_client<: info du client wifi
// Sortie		: <loc_u8_resultat>: TRUE, si OK, sinon FALSE
// Auteur		: CM - 26/01/2010 -
// Description	: Mise à jour du statut du client Wifi (mode WPA)
//=====================================================================================
u8sod u8MajStatutClientWifi(S_STRUC_EXP_ACCESS_POINT *loc_ps_exp_accesspoint, S_STRUCT_EXP_WIFI_CLIENT *loc_ps_exp_wifi_client)
{
	u8sod	loc_u8_resultat;
	u16sod	loc_u16_i;
	u16sod	loc_u16_idx_client;
	u8sod	loc_u8_trouve;

	loc_u8_resultat = FALSE;	//INIT
	loc_u8_trouve = FALSE; //INIT
	loc_u16_idx_client = 0;	//INIT

	//Recherche si ce client existe dans la base de données d'exploitation
	for(loc_u16_i=0;loc_u16_i<NB_ASSOCIATED_STATIONS_MAX;loc_u16_i++)
	{
		if(TRUE == loc_ps_exp_accesspoint->s_wifi_client[loc_u16_i].u8_present)//CONDITION: client Wifi présent dans la bdd exploit
		{
			if(0 == memcmp(loc_ps_exp_wifi_client->pu8_add_mac, loc_ps_exp_accesspoint->s_wifi_client[loc_u16_i].pu8_add_mac, ETHER_ADDR_LEN))
			{
//				printf("client trouve[%d]\n",loc_u16_i);
				//client trouvé
				loc_u16_idx_client = loc_u16_i;
				loc_u8_trouve = TRUE;
				loc_u16_i = NB_ASSOCIATED_STATIONS_MAX + 1;	//on sort
			}
		}
	}

	if((TRUE == loc_u8_trouve)&&(loc_u16_idx_client<NB_ASSOCIATED_STATIONS_MAX)) //CONDITION: client déjà présent
	{
		//donc maj statut du client
		loc_ps_exp_accesspoint->s_wifi_client[loc_u16_idx_client].u32_statut = loc_ps_exp_wifi_client->u32_statut; //MAJ
		loc_ps_exp_accesspoint->s_wifi_client[loc_u16_idx_client].u32_time_reconnexion = loc_ps_exp_wifi_client->u32_time_reconnexion; //MAJ

		loc_u8_resultat = TRUE;
	}
	else //CONDITION: nouveau client
	{
		MACRO_PRINTF(("u8MajStatutClientWifi: Client non référence %s\n",ps8GetChAddressMac(loc_ps_exp_wifi_client->pu8_add_mac)));
	}

	return loc_u8_resultat;
}/*u8MajStatutClientWifi*/

//=====================================================================================
// Fonction		: MiseAJour_ExploitWPAClientsWifi
// Entrees		: <loc_ps_exp_accesspoint<: exploitation (RAM) pour ce processus
// Sortie		: rien
// Auteur		: CM - 26/01/2010 -
// Description	: Mise à jour de l'exploitaion WPA des clients Wifi de l'Access Point
//=====================================================================================
void MiseAJour_ExploitWPAClientsWifi(S_STRUC_EXP_ACCESS_POINT *loc_ps_exp_accesspoint)
{
	u8sod	loc_u8_resultat;
	FILE *	loc_p_handle;
	s8sod	*loc_ps8_result_fgets;
	s8sod	loc_ps8_ligne[TAILLE_MAX_LIGNE_HOSTAPD_DUMP+1];
	u8sod loc_u8_i;
	u32sod	loc_pu32_addr_mac[ETHER_ADDR_LEN];
	S_STRUCT_EXP_WIFI_CLIENT loc_s_wifi_client;
	u16sod	loc_u16_cpt;
	s32sod	loc_s32_sscanf;
	u32sod	loc_u32_time_reconnexion;
	
	s32sod	loc_s32_pid;

	loc_u8_resultat = TRUE; //INIT
	loc_p_handle = NULL;	//INIT
	loc_ps8_result_fgets = NULL; //INIT
	strcpy(loc_ps8_ligne, ""); //INIT
	for(loc_u8_i=0;loc_u8_i<ETHER_ADDR_LEN;loc_u8_i++)
	{
		loc_pu32_addr_mac[loc_u8_i] = 0;	//INIT
	}
	memset(&loc_s_wifi_client, 0, sizeof(S_STRUCT_EXP_WIFI_CLIENT)); //INIT
	loc_u16_cpt = 0;	//INIT
	loc_s32_sscanf = 0; //INIT
	loc_s32_pid = -1;	//INIT
	loc_u32_time_reconnexion = 0; //INIT

	//Détermination PID du processus hostapd
	loc_s32_pid = s32ReadPid_InFile(FICHIER_VAR_HOSTAPD_PID);

	if(loc_s32_pid > 0) //CONDITION: Processus hostapd en cours d'execution
	{
		if(NULL == (loc_p_handle = fopen(FICHIER_HOSTAPD_DUMP, "rt")))
		{
			//On ne signale rien car c'est peut-etre la première fois  
			loc_u8_resultat = FALSE; //on sort
		}
		else
		{
			//printf("========================\n");
			//CmdSystem_Generique("cat %s",FICHIER_HOSTAPD_DUMP);
			//printf("========================\n");
			//Lecture du fichier / extraction des informations
			//------------------------------------------------------
			//	hostapd state dump - Thu Oct  1 00:00:58 2009 
			//	num_sta=1 num_sta_non_erp=0 num_sta_no_short_slot_time=0 
			//	num_sta_no_short_preamble=0 
			//
			//  STA=00:1c:bf:bf:82:df 
			//	  AID=0 flags=0x23 [AUTH][ASSOC][AUTHORIZED] 
			//	  capability=0x0 listen_interval=0 
			//	time_reconnexion=%08X
			//	timeout_next=NULLFUNC POLL
			//  ....
			//------------------------------------------------------
			
			loc_u16_cpt = 0;	//RAZ
			do{
				loc_ps8_result_fgets = fgets(loc_ps8_ligne,TAILLE_MAX_LIGNE_HOSTAPD_DUMP,loc_p_handle);
				if(NULL != loc_ps8_result_fgets) //CONDITION: ligne lue
				{
					//Recherche ligne avec 'STA='
					if(NULL != strstr(loc_ps8_ligne, "STA=")) //CONDITION: ligne avec 'STA='
					{
						//Nouvelle station
						memset(&loc_s_wifi_client, 0, sizeof(S_STRUCT_EXP_WIFI_CLIENT)); //RAZ
						//On lit l'adresse MAC
						loc_s32_sscanf = sscanf(loc_ps8_ligne, "%*[^=]=%02lX:%02lX:%02lX:%02lX:%02lX:%02lX",
												&loc_pu32_addr_mac[0], &loc_pu32_addr_mac[1],
												&loc_pu32_addr_mac[2], &loc_pu32_addr_mac[3],
												&loc_pu32_addr_mac[4], &loc_pu32_addr_mac[5]);
						if(ETHER_ADDR_LEN != loc_s32_sscanf)//CONDITION: lecture KO
						{
							loc_u8_resultat = FALSE; //on sort
						}
						else
						{
							for(loc_u8_i=0;loc_u8_i<ETHER_ADDR_LEN;loc_u8_i++)
							{
								loc_s_wifi_client.pu8_add_mac[loc_u8_i] = (u8sod)loc_pu32_addr_mac[loc_u8_i];
							}
							loc_s_wifi_client.u8_present = TRUE; 
						}
//						printf("MiseAJour_ExploitWPAClientsWifi: STA=%s\n",ps8GetChAddressMac(loc_s_wifi_client.pu8_add_mac));
					}
					else
					{
						if(NULL != strstr(loc_ps8_ligne, "flags=")) //CONDITION: ligne avec 'flags='
						{
							//On lit les informations
							if(TRUE == loc_s_wifi_client.u8_present)
							{
								if(NULL != strstr(loc_ps8_ligne, "[AUTH]")) //CONDITION: ligne avec '[AUTH]'
								{
									loc_s_wifi_client.u32_statut |= (u32sod)(1 << BIT0_STA_CLIENTWIFI_AUTHENTICATED);
								}
								else
								{
									loc_s_wifi_client.u32_statut &= (u32sod)(~(1 << BIT0_STA_CLIENTWIFI_AUTHENTICATED));
								}
								if(NULL != strstr(loc_ps8_ligne, "[ASSOC]")) //CONDITION: ligne avec '[ASSOC]'
								{
									loc_s_wifi_client.u32_statut |= (u32sod)(1 << BIT1_STA_CLIENTWIFI_ASSOCIATED);
								}
								else
								{
									loc_s_wifi_client.u32_statut &= (u32sod)(~(1 << BIT1_STA_CLIENTWIFI_ASSOCIATED));
								}
								if(NULL != strstr(loc_ps8_ligne, "[AUTHORIZED]")) //CONDITION: ligne avec '[AUTHORIZED]'
								{
									loc_s_wifi_client.u32_statut |= (u32sod)(1 << BIT2_STA_CLIENTWIFI_AUTHORIZED);
								}
								else
								{
									loc_s_wifi_client.u32_statut &= (u32sod)(~(1 << BIT2_STA_CLIENTWIFI_AUTHORIZED));
								}
//								printf("loc_s_wifi_client.u32_statut =>%d\n",loc_s_wifi_client.u32_statut);
							}
						}
						else
						{
							if(NULL != strstr(loc_ps8_ligne, "time_reconnexion=")) //CONDITION: ligne avec 'time_reconnexion='
							{
								
								loc_s32_sscanf = sscanf(loc_ps8_ligne, "%*[^=]=%08lX",
									&loc_u32_time_reconnexion);
								
								if(1 != loc_s32_sscanf)//CONDITION: lecture KO
								{
									loc_u8_resultat = FALSE; //on sort
								}
								else
								{
									loc_s_wifi_client.u32_time_reconnexion = loc_u32_time_reconnexion;
								}
							}
							else
							{
								if(NULL != strstr(loc_ps8_ligne, "timeout_next=")) //CONDITION: dernière ligne
								{
									if(TRUE == loc_s_wifi_client.u8_present)
									{
										//printf("MiseAJour_ExploitWPAClientsWifi: u8MajStatutClientWifi %s =>%d\n",
										//	   ps8GetChAddressMac(loc_s_wifi_client.pu8_add_mac), loc_s_wifi_client.u32_statut);
										if(FALSE == u8MajStatutClientWifi(loc_ps_exp_accesspoint, &loc_s_wifi_client))
										{
#ifdef _WRM100_N_SELECT
//											printf("MiseAJour_ExploitWPAClientsWifi: u8MajStatutClientWifi KO\n");
#warning "A DECOMMENTER QUAND defaut incoherence liste station corrige dans hostapd (sinon pollue la console de AP)"
#endif
#ifdef _WRM100_ABG_SELECT
											printf("MiseAJour_ExploitWPAClientsWifi: u8MajStatutClientWifi KO\n");
#endif
										}
									}
									memset(&loc_s_wifi_client, 0, sizeof(S_STRUCT_EXP_WIFI_CLIENT)); //RAZ
								}
							}
						}
					}
				}

				loc_u16_cpt ++;

			}while((NULL != loc_ps8_result_fgets) &&
				   (loc_u16_cpt < (NB_ASSOCIATED_STATIONS_MAX*60+200)) && //*60: car 60 au moins lignes d'infos par station (inclu ligne vide) + 200 autres lignes maximum
				   (TRUE == loc_u8_resultat)
				  );
			
			//fermeture du fichier
			fclose(loc_p_handle);
		}

		//On demande le fichier hostapd.dump (pour la prochaine seconde)
		//On envoie alors le signal qui permet à hostapd de générer le fichier hostapd.dump
//		printf("kill -USR1 loc_s32_pid=%d\n",loc_s32_pid);
		CmdSystem_Generique("kill -USR1 %d",loc_s32_pid);
	}
	
}/*MiseAJour_ExploitWPAClientsWifi*/

//=====================================================================================
// Fonction		: ExtractExploitWifiAccessPoint
// Entrees		: <loc_ps_config< : configuration (RAM) pour ce processus
//				: <loc_ps_exploit<: exploitation (RAM) pour ce processus
// Sortie		: rien
// Auteur		: CM - 26/01/2010 -
// Description	: extraction exploitation Wifi (access point)
//=====================================================================================
void ExtractExploitWifiAccessPoint(S_STRUCT_CONFIGURATION *loc_ps_config, S_STRUCT_EXPLOITATION *loc_ps_exploit)
{
	u16sod loc_u16_i;
	
	if(TRUE == u8FillExploitAccessPointFile(&loc_ps_exploit->s_access_point))
	{
		//On resete l'info qui signale que le client a été mis à jour
		for(loc_u16_i=0;loc_u16_i<NB_ASSOCIATED_STATIONS_MAX;loc_u16_i++)
		{
			loc_ps_exploit->s_access_point.s_wifi_client[loc_u16_i].u8_flag_maj = FALSE; //RAZ
		}
		
#ifdef _WRM100_ABG_SELECT
		//Puis on extrait et mise à jour des clients Wifi
		WlanABG_MiseAJour_TableClientsWifi(&loc_ps_exploit->s_access_point);
#endif
#ifdef _WRM100_N_SELECT
		WlanN_MiseAJour_TableClientsWifi(&loc_ps_exploit->s_access_point);
#endif

		//On gère les informations associées à la sécurité Wifi
		switch(loc_ps_config->s_wifi.u8_mode_securite_wifi)
		{
			case MODE_SECURITE_WIFI_AUCUN:
			case MODE_SECURITE_WIFI_WEP:
				for(loc_u16_i=0;loc_u16_i<NB_ASSOCIATED_STATIONS_MAX;loc_u16_i++)
				{
					loc_ps_exploit->s_access_point.s_wifi_client[loc_u16_i].u32_statut &= (u32sod)~(1<<BIT2_STA_CLIENTWIFI_AUTHORIZED); //RAZ
				}
				break;
			case MODE_SECURITE_WIFI_WPA:
			case MODE_SECURITE_WIFI_WPA_TKIP:
			case MODE_SECURITE_WIFI_WPA_AES:
			case MODE_SECURITE_WIFI_WPA2:
			case MODE_SECURITE_WIFI_WPA2_TKIP:
			case MODE_SECURITE_WIFI_WPA2_AES:
				MiseAJour_ExploitWPAClientsWifi(&loc_ps_exploit->s_access_point);
				break;
			default:
				break;
		}

		//On resete les clients qui n'ont pas été maj
		for(loc_u16_i=0;loc_u16_i<NB_ASSOCIATED_STATIONS_MAX;loc_u16_i++)
		{
			if(FALSE == loc_ps_exploit->s_access_point.s_wifi_client[loc_u16_i].u8_flag_maj)//CONDITION: maj non effectué du client Wifi
			{
				//on le supprime de la bdd exploit
				InitExpWifiClient(&loc_ps_exploit->s_access_point.s_wifi_client[loc_u16_i]); //RAZ
			}
		}

#ifdef _WRM100_N_SELECT
		//Canal en cours
		loc_ps_exploit->s_access_point.u16_channel_inprogress = (u16sod)t_driverWifiN_userinfo.u8_ieee_inprogress;
		loc_ps_exploit->s_access_point.u16_freq_MHz_inprogress = t_driverWifiN_userinfo.u16_freq_MHz_inprogress;
#endif
		
		//On edite le fichier
		u8EditExploitAccessPointFile(&loc_ps_exploit->s_access_point);
	}

}/*ExtractExploitWifiAccessPoint*/

/*_____VII - PROCEDURE D'INITIALISATION __________________________________*/

//=====================================================================================
// Fonction		: InitModule_Exp_Wifi_AP
// Entrees		: rien
// Sortie		: rien
// Auteur		: CM - 26/01/2010 -
// Description	: Initialisation du module de exp_wifi_ap
//=====================================================================================
void InitModule_Exp_Wifi_AP(void)
{
	
}/*InitModule_Exp_Wifi_AP*/

