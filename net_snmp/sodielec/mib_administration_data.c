/*========================================================================*/
/* NOM DU FICHIER  : mib_administration_data.c							  */
/*========================================================================*/
/* Compilateur     : GCC                                                  */
/* Linking locator : GCC                                                  */
/* Formatter       : GCC                                                  */
/* Auteur          : CM                                                   */
/* Date			   : 07/06/2007                                           */
/* Libelle         : NET-SNMP: MIB ADMINISTRATION						  */
/* Projet          : WRM100                                               */
/* Indice          : BE019                                                */
/*========================================================================*/
/* Historique      :                                                      */
/*
 * Note: this file originally auto-generated by mib2c using
 *         mib2c.sodielec_format.conf, v1.0 Juin 2006
 * Version: PC_SOUS_LINUX: 0, CARTE_EVAL: 0 [oui(1), non(0)]
 * Date: Mon Jun 12 10:39:44 2006
 */
//BE019 16/03/2010 CM
// - CREATION source basée sur SDVB200 BE373
/*========================================================================*/

/*_______II - DEFINE ______________________________________________________*/
#define MIB_ADMINISTRATION_DATA_H

/*_______III - INCLUDES - DIRECTIVES ______________________________________*/
#include "headers.h"
#include "mib_administration_data.h"

/*_______IV  - PROTOTYPES IMPORTES _____________________MODULE______________*/
/** Function declarations */
/** ** for MIB Tree       */
WriteMethod write_mgmtV1ReemissionTrap;
WriteMethod write_mgmtV1SigneVieCmd;
WriteMethod write_mgmtV1SigneVieCycle;
WriteMethod write_mgmtV1AutorisationTrap;

/** ** for Tables         */
WriteMethod write_evtV1cfgNiveauGravite;
WriteMethod write_evtV1cfgAction;
WriteMethod write_evtV1PrototrapCycle;
WriteMethod write_evtV1PrototrapNombre;
WriteMethod write_alarmeV1Acquit;


/*_______VI  - PROCEDURES __________________________________________________*/
/** Capture functions */
/** ** for MIB Tree       */
char *
   captureString_administration(int vpmagic, WriteMethod ** write_method)
{
	s8sod	*loc_ps8_cp;

	loc_ps8_cp = NULL; //INIT
	
	switch (vpmagic) {
		case EQUINFOV1NOM:
			loc_ps8_cp = ps8ConvertChaineToSnmp((s8sod*)S_DESCRIPT_EQUIPEMENT[ u8_snmp_type_equipement ].ps8_nom[u8_snmp_langue]);
			break;
		case EQUINFOV1LOCALISATION:
			loc_ps8_cp = &s_config_process_snmpd.s_admin.ps8_identifiant[0];
			break;
		case EQUINFOV1ID:
			loc_ps8_cp = &s_config_process_snmpd.s_admin.ps8_localisation[0];
			break;
		default:
			DEBUGMSGTL(("sodielec", "unknown sub-id %d in captureString_administration\n", vpmagic));
			break;
	}
	return loc_ps8_cp;
}

long
   captureInt_administration(int vpmagic, WriteMethod ** write_method)
{
	long_return = 0; //INIT
	
	switch (vpmagic) {
		case MGMTV1REEMISSIONTRAP:
			if(VERSION_SNMPV1 == s_config_process_snmpd.s_snmp.u8_version_snmp) //CONDITION: uniquement SNMPv1
			{
				long_return = 1; // off(1) : par défaut
				*write_method = write_mgmtV1ReemissionTrap;
			}
			else
			{
				long_return = 0;
			}
			break;
		case MGMTV1SIGNEVIECMD:
			if (TRUE == s_config_process_snmpd.s_snmp.s_trap_signevie.u8_activation)
			{
				long_return = 2;	//on
			}
			else
			{
				long_return = 1;	//off
			}
			*write_method = write_mgmtV1SigneVieCmd;
			break;
		case MGMTV1SIGNEVIECYCLE:
			long_return = s_config_process_snmpd.s_snmp.s_trap_signevie.u16_cycle;
			*write_method = write_mgmtV1SigneVieCycle;
			break;
		case MGMTV1AUTORISATIONTRAP:
			if (EMISSION_TRAP_INACTIVE == s_config_process_snmpd.s_snmp.u8_emission_trap)
			{
				long_return = 1;	//off
			}
			else
			{
				long_return = 2;	//on
			}
			*write_method = write_mgmtV1AutorisationTrap;
			break;
		default:
			DEBUGMSGTL(("sodielec", "unknown sub-id %d in captureInt_administration\n", vpmagic));
			break;
	}
	return long_return;
}


/** ** for Tables         */
// Fonctions pour evtV1configTable
char *
   captureString_evtV1configTable(int vpmagic, int iindex, WriteMethod ** write_method)
{
	s8sod	*loc_ps8_cp;
	u16sod	loc_u16_indEvt;
	
	loc_ps8_cp = NULL; //INIT

	//On recherche index de l'evt (car iindex = numéro de l'évt)
	loc_u16_indEvt = u16RechercheIndiceEvt((u16sod)iindex);
	if(US_INDICE_NON_TROUVE != loc_u16_indEvt)
	{
		switch (vpmagic) {
			case EVTV1CFGEQUIPEMENT:
				loc_ps8_cp = ps8ConvertChaineToSnmp((s8sod*)S_DESCRIPT_EQUIPEMENT[ u8_snmp_type_equipement ].ps8_nom[u8_snmp_langue]);
				break;
			case EVTV1CFGDESCRIPTION:
				loc_ps8_cp = ps8ConvertChaineToSnmp(pt_tb_msg[u8_snmp_langue].ps8_msg_lib_evenement[loc_u16_indEvt]);
				break;
			default:
				DEBUGMSGTL(("sodielec", "unknown sub-id %d in captureString_evtV1configTable\n", vpmagic));
				break;
		}
	}
	else
	{
		DEBUGMSGTL(("sodielec", "u16RechercheIndiceEvt KO: %d in captureString_evtV1configTable\n", iindex));
	}
	
	return loc_ps8_cp;
}

long
   captureInt_evtV1configTable(int vpmagic, int iindex, WriteMethod ** write_method)
{
	u16sod	loc_u16_indEvt;
	S_STRUCT_CFG_EVENT loc_s_cfg_evt;
	s32sod	loc_s32_sem;

	long_return = 0; //INIT
	
	//On recherche index de l'evt (car iindex = numéro de l'évt)
	loc_u16_indEvt = u16RechercheIndiceEvt((u16sod)iindex);
	if(US_INDICE_NON_TROUVE != loc_u16_indEvt)
	{
		loc_s_cfg_evt = s_config_process_snmpd.s_tabevt.s_event[loc_u16_indEvt];
	}
	
	if(US_INDICE_NON_TROUVE != loc_u16_indEvt)
	{
		switch (vpmagic) {
			case EVTV1CFGINDEX:
				long_return = iindex;
				break;
			case EVTV1CFGID:
				long_return =  S_DESCRIPTION_EVENT_PAR_DEFAUT[loc_u16_indEvt].u16_numero_evt;
				break;
			case EVTV1CFGNIVEAUGRAVITE:
				long_return = loc_s_cfg_evt.u8_niveau_gravite+1;
				*write_method = write_evtV1cfgNiveauGravite;
				break;
			case EVTV1CFGACTION:
				if(TRUE == u8GetEventAction(loc_s_cfg_evt.u16_action, ACTION_EVT_TRAP))
				{
					long_return = 2;	//trap
				}
				else
				{
					long_return = 1;	//aucune
				}
				*write_method = write_evtV1cfgAction;
				break;
			case EVTV1CFGTYPE:
				if(TYPE_EVT_ALARME == S_DESCRIPTION_EVENT_PAR_DEFAUT[loc_u16_indEvt].u8_type_evt)
				{
					long_return = 1;	//alarme
				}
				else
				{ 
					long_return = 2;	//info
				}
				break;
			default:
				DEBUGMSGTL(("sodielec", "unknown sub-id %d in captureInt_evtV1configTable\n", vpmagic));
				break;
		}
	}
	else
	{
		DEBUGMSGTL(("sodielec", "u16RechercheIndiceEvt KO: %d in captureInt_evtV1configTable\n", iindex));
	}
	
	return long_return;
}

// Fonctions pour evtV1PrototrapTable
char *
   captureString_evtV1PrototrapTable(int vpmagic, int iindex, WriteMethod ** write_method)
{
	s8sod	*loc_ps8_cp;
	loc_ps8_cp = NULL;
	
	switch (vpmagic) {
		default:
			DEBUGMSGTL(("sodielec", "unknown sub-id %d in captureInt_evtV1PrototrapTable\n", vpmagic));
			break;
	}
	return loc_ps8_cp;
}

long
   captureInt_evtV1PrototrapTable(int vpmagic, int iindex, WriteMethod ** write_method)
{
	long_return = 0; //INIT

	if(VERSION_SNMPV1 == s_config_process_snmpd.s_snmp.u8_version_snmp) //CONDITION: uniquement SNMPv1
	{
		switch (vpmagic) {
			case EVTV1PROTOTRAPINDEX:
				long_return = iindex + 1;
				break;
			case EVTV1PROTOTRAPNIVEAUGRAVITE:
				long_return = iindex + 1;
				break;
			case EVTV1PROTOTRAPCYCLE:
				long_return = s_config_process_snmpd.s_snmp.s_trap_SNMPv1[iindex].u16_interval;
				*write_method = write_evtV1PrototrapCycle;
				break;
			case EVTV1PROTOTRAPNOMBRE:
				long_return = s_config_process_snmpd.s_snmp.s_trap_SNMPv1[iindex].u16_nb_emission;
				*write_method = write_evtV1PrototrapNombre;
				break;
			default:
				DEBUGMSGTL(("sodielec", "unknown sub-id %d in captureInt_evtV1PrototrapTable\n", vpmagic));
				break;
		}
	}
	else
	{
		long_return = 0;
	}
	return long_return;
}



void
   initdata_mib_administration(void) {
}
